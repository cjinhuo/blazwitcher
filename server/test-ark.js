// è°ƒè¯•ç”¨
const currentWindowData = {
	windowId: 819044940,
	ungroupedTabs: [
		{
			itemType: 'tab',
			data: {
				id: 819044939,
				title: 'React è¿›é˜¶å®è·µæŒ‡å— - æˆ‘ä¸æ˜¯å¤–æ˜Ÿäºº - æ˜é‡‘å°å†Œ',
				url: 'https://juejin.cn/book/6945998773818490884/section/6948353204413268001?enter_from=search_result&utm_source=search',
				host: 'juejin.cn',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044941,
				title: 'mitojs',
				url: 'https://github.com/mitojs',
				host: 'github.com',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044942,
				title: 'fin-pre.bytedance.com/payb/front/next/verification-document/list',
				url: 'https://fin-pre.bytedance.com/payb/front/next/verification-document/list',
				host: 'fin-pre.bytedance.com',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044943,
				title: 'å¯¹å…¬æ”¯å‡º-åˆ—è¡¨',
				url: 'https://fin-pre.bytedance.com/payb/front/next/payment-request/list',
				host: 'fin-pre.bytedance.com',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819045025,
				title: 'å¯¹å…¬æ”¯å‡ºå•-åˆ›å»º',
				url: 'https://fin-pre.bytedance.com/payb/front/next/payment-request/create?biz_key=G2025081280001067',
				host: 'fin-pre.bytedance.com',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819045027,
				title: 'ä¾›åº”å•†ç®¡ç†å¹³å°',
				url: 'https://procurement-pre.bytedance.net/supplier-manage/detail/fin?source=fin&takeOverToast=false&mdmCode=MDCP00484710&supId=V200347127&_preset_mode=updating&status=edit&bu=BU99&businessType=3#base',
				host: 'procurement-pre.bytedance.net',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044945,
				title: 'å›¢å»ºç”³è¯·',
				url: 'https://travel.bytedance.com/tb/apply',
				host: 'travel.bytedance.com',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044944,
				title: 'Coze Slardar JS æŠ¥é”™æ²»ç† - é£ä¹¦äº‘æ–‡æ¡£',
				url: 'https://bytedance.larkoffice.com/wiki/RY0NwtvLpijiDkkc0lAcpZhenYf',
				host: 'bytedance.larkoffice.com',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044949,
				title: 'ã€å›¢å»ºç”³è¯·ã€‘ BOE/PREå°æµé‡Â·æµæ°´çº¿',
				url: 'https://bits.bytedance.net/devops/4084993794/pipeline/detail/10988504?fromBytecycle=true&devops_space_type=server_fe&enterType=url&activeTab=0&configs=%7B%7D',
				host: 'bits.bytedance.net',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819044974,
				title: 'æ•°æ®æ¢ç´¢',
				url: 'https://slardar-us.bytedance.net/node/web/data_search?env=Slardar_All&bid=ea_expense_hermes_front&lang=zh&site_type=web&region=maliva&subregion=row&start_time=1754841600&end_time=1754919258&layout=normal&ev_type=session&granularity=auto',
				host: 'slardar-us.bytedance.net',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819045056,
				title: 'Prompt å¼€å‘',
				url: 'https://fornax.bytedance.net/space/7413735413308719106/prompt/develop/7535388483112665089',
				host: 'fornax.bytedance.net',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819045111,
				title: 'chrome æœ¬åœ°å¤§æ¨¡å‹ - Google æœç´¢',
				url: 'https://www.google.com.hk/search?q=chrome+%E6%9C%AC%E5%9C%B0%E5%A4%A7%E6%A8%A1%E5%9E%8B&rlz=1C5GCEM_enCN1098CN1116&oq=chrome+%E6%9C%AC%E5%9C%B0%E5%A4%A7%E6%A8%A1%E5%9E%8B&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIKCAEQABiABBiiBDIKCAIQABiABBiiBDIKCAMQABiABBiiBNIBCDc0MTRqMGoxqAIAsAIA&sourceid=chrome&ie=UTF-8',
				host: 'www.google.com.hk',
			},
		},
		{
			itemType: 'tab',
			data: {
				id: 819045112,
				title: 'Built-in AI APIs  |  AI on Chrome  |  Chrome for Developers',
				url: 'https://developer.chrome.com/docs/ai/built-in-apis',
				host: 'developer.chrome.com',
			},
		},
	],
	existingGroups: [
		{
			id: 1002266473,
			title: 'å¯¹å…¬å¹³å°',
			color: 'green',
			memberCount: 1,
			hosts: ['bits.bytedance.net'],
			tabs: [
				{
					title: 'å‘å¸ƒÂ·EAè´¢åŠ¡å‰ç«¯-ç«è½¦å‘å¸ƒç©ºé—´',
					url: 'https://bits.bytedance.net/devops/4402483714/release?devops_space_type=server_fe&filters=%5B%5D&order=0&page=1&pipelineId=969949355522&releaseTab=flow&stage=965013132034&statusList=1&tab=pipeline&viewId=view-all',
					host: 'bits.bytedance.net',
					windowId: 819044940,
				},
			],
		},
		{
			id: 536467103,
			title: 'slardarç›‘æ§',
			color: 'grey',
			memberCount: 2,
			hosts: ['slardar.bytedance.net'],
			tabs: [
				{
					title: 'æ–°ç‰ˆå‰ç«¯ç›‘æ§è¯¦æƒ…',
					url: 'https://slardar.bytedance.net/node/web_org/overview?oid=ea_expense&site_type=web&org_type=0&start_time=1720052474&end_time=1720056074&lang=zh&env=production',
					host: 'slardar.bytedance.net',
					windowId: 819044940,
				},
				{
					title: 'JS æ€»è§ˆ',
					url: 'https://slardar.bytedance.net/node/web/js?env=prd&bid=payb&lang=zh&start_time=1753804800&end_time=1755014400&site_type=web&region=cn&subregion=undefined&layout=normal&filter_id=e1ca33299450107b1bdfd95971b8fd47&granularity=auto&time_shortcut=undefined&current_error_page=1',
					host: 'slardar.bytedance.net',
					windowId: 819044940,
				},
			],
		},
	],
	summary: {
		totalTabs: 16,
		ungroupedTabs: 13,
		existingGroupsCount: 2,
	},
}

const testSimple = async () => {
	const baseURL = 'http://localhost:3000'

	console.log('ğŸ§ª æµ‹è¯• ARK æµå¼è°ƒç”¨...')

	try {
		const response = await fetch(`${baseURL}/ark/categorize-tabs`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				data: currentWindowData,
			}),
		})

		console.log('å“åº”çŠ¶æ€:', response.status)

		if (response.ok) {
			const reader = response.body.getReader()
			const decoder = new TextDecoder()
			let eventCount = 0

			console.log('å¼€å§‹æ¥æ”¶SSEäº‹ä»¶...')

			// ç”¨äºå­˜å‚¨è§£æåçš„æ•°æ®
			let statistics = null
			let addToExistingGroups = []
			let createNewGroups = []
			let processedGroups = new Set()
			let jsonBuffer = ''

			while (true) {
				const { done, value } = await reader.read()
				if (done) break

				const chunk = decoder.decode(value)

				const lines = chunk.split('\n').filter((line) => line.trim())

				for (const line of lines) {
					if (line.startsWith('data: ')) {
						const data = line.slice(6)
						eventCount++

						if (data === '[DONE]') {
							console.log(`ğŸ“¡ æ”¶åˆ° [DONE] äº‹ä»¶ï¼Œæ€»å…± ${eventCount} ä¸ªäº‹ä»¶`)
							break
						}

						try {
							const parsed = JSON.parse(data)

							const content = parsed.choices?.[0]?.delta?.content || ''

							if (content) {
								jsonBuffer += content

								// æ¯10ä¸ªchunkå¤„ç†ä¸€æ¬¡ï¼Œæé«˜å®æ—¶æ€§
								if (eventCount % 10 === 0) {
									await processStreamData(jsonBuffer)
								}
							}
						} catch (e) {
							console.log('è§£æchunkå¤±è´¥:', line, e.message)
						}
					}
				}
			}

			// æœ€ç»ˆå¤„ç†
			await processStreamData(jsonBuffer)

			// å¤„ç†æµå¼æ•°æ®çš„å‡½æ•°
			async function processStreamData(jsonBuffer) {
				try {
					// 1. è§£æç»Ÿè®¡ä¿¡æ¯
					if (!statistics && jsonBuffer.includes('"statistics"')) {
						const statsMatch = jsonBuffer.match(/"statistics":\s*({[^}]+})/)
						if (statsMatch) {
							try {
								const statsData = JSON.parse(statsMatch[1])
								statistics = statsData
								console.log(
									`ğŸ“Š ç»Ÿè®¡ä¿¡æ¯: æ·»åŠ ç°æœ‰ç»„ ${statsData.tabsToAddToExisting} ä¸ª, åˆ›å»ºæ–°ç»„ ${statsData.tabsToCreateNewGroups} ä¸ª`
								)
							} catch (e) {
								// ç»Ÿè®¡ä¿¡æ¯ä¸å®Œæ•´ï¼Œç»§ç»­ç­‰å¾…
							}
						}
					}

					// 2. è§£æaddToExistingGroups
					if (jsonBuffer.includes('"addToExistingGroups"')) {
						const existingMatch = jsonBuffer.match(/"addToExistingGroups":\s*(\[[\s\S]*?\])/)
						if (existingMatch) {
							try {
								const existingData = JSON.parse(existingMatch[1])
								if (existingData.length !== addToExistingGroups.length) {
									for (const item of existingData) {
										if (item.tabId && item.groupId) {
											const key = `existing_${item.tabId}_${item.groupId}`
											if (!processedGroups.has(key)) {
												processedGroups.add(key)
												console.log(`ğŸš€ ç«‹å³æ‰§è¡Œ: å°†tab ${item.tabId} æ·»åŠ åˆ°ç»„ ${item.groupId}`)
											}
										}
									}
									addToExistingGroups = existingData
								}
							} catch (e) {
								// æ•°æ®ä¸å®Œæ•´ï¼Œç»§ç»­ç­‰å¾…
							}
						}
					}

					// 3. è§£æcreateNewGroups
					if (jsonBuffer.includes('"createNewGroups"')) {
						const startIndex = jsonBuffer.indexOf('"createNewGroups"')
						const afterColon = jsonBuffer.indexOf('[', startIndex)
						if (afterColon === -1) {
							return
						}

						let bracketCount = 0
						let inString = false
						let escapeNext = false
						let endIndex = -1

						for (let i = afterColon; i < jsonBuffer.length; i++) {
							const char = jsonBuffer[i]

							if (escapeNext) {
								escapeNext = false
								continue
							}

							if (char === '\\') {
								escapeNext = true
								continue
							}

							if (char === '"' && !escapeNext) {
								inString = !inString
								continue
							}

							if (!inString) {
								if (char === '[') bracketCount++
								else if (char === ']') {
									bracketCount--
									if (bracketCount === 0) {
										endIndex = i + 1
										break
									}
								}
							}
						}

						if (endIndex !== -1) {
							try {
								const newGroupsStr = jsonBuffer.substring(afterColon, endIndex)
								const newGroupsData = JSON.parse(newGroupsStr)

								if (newGroupsData.length !== createNewGroups.length) {
									console.log(`ğŸ”„ å‘ç°æ–°çš„createNewGroupsæ•°æ®ï¼Œæ•°é‡: ${newGroupsData.length}`)
									for (const group of newGroupsData) {
										if (group.groupTitle && group.groupColor && group.tabIds) {
											const key = `new_${group.groupTitle}_${group.tabIds.join('_')}`
											if (!processedGroups.has(key)) {
												processedGroups.add(key)
												console.log(
													`ğŸš€ ç«‹å³æ‰§è¡Œ: åˆ›å»ºæ–°ç»„ "${group.groupTitle}" (${group.groupColor}) åŒ…å«tabs ${group.tabIds.join(', ')}`
												)
											}
										}
									}
									createNewGroups = newGroupsData
								}
							} catch (e) {
								// è§£æå¤±è´¥ï¼Œç»§ç»­ç­‰å¾…æ›´å¤šæ•°æ®
							}
						}
					}
				} catch (error) {
					// è§£æé”™è¯¯ï¼Œç»§ç»­ç­‰å¾…æ›´å¤šæ•°æ®
				}
			}

			console.log(`âœ… æµå¼è°ƒç”¨æˆåŠŸï¼Œæ¥æ”¶ ${eventCount} ä¸ªäº‹ä»¶`)
		} else {
			const errorText = await response.text()
			console.log('âŒ è°ƒç”¨å¤±è´¥:', errorText)
		}
	} catch (error) {
		console.error('âŒ è¯·æ±‚å¤±è´¥:', error.message)
	}
}

testSimple().catch(console.error)
